# Мешков Роман ШМС-211
### Варинт 1 / 18 

# Отчет по лабораторным работам по дисциплине Математическое и Компьютерное моделирование

## Лабораторная работа № 1

### Градиентного спуска
Работа представлена в файлах  `gradient_descent.py` и в `gradient_descent.ipynb`
Целью работы являться изучение и применения метода </u>градиентного спуска</u> для нахождения локального минимума элементарных функций.

В данной работе была предоставлена Исходная функция f(x)
```
def f(x):
    return 5 * (np.sin(2 * np.pi * 10 * x) / 2 * np.pi * 10 * x) * np.cos(2 * np.pi)
```
После чего необходимо надо было найти производнуб данной функции df(x)
```
def df(x):
    return (2 * np.cos(x ** 2) - np.sin(x ** 2)) / (x ** 2)
```
По данным функциям были построенны графики представлены в функциях `gradient_f` и ` gradient_df`

В функции `gradient_descent_2` представлен градиентный спуск
```
def gradient_descent_2():
    y_min_global = 0
    x_min_global = 0

    for _ in range(100):
        x = random.uniform(x_start, x_end)

        for i in range(1000):
            learning_rate = 1 / min(i + 10, 100)
            x = x - learning_rate * np.sign(df(x))
            if x < x_start - (x_start / 10) or x > x_end - (x_end / 10):
                break
            else:
                y_min_local = f(x)

            if y_min_local < y_min_global:
                y_min_global = y_min_local
                x_min_global = x

    print(f'global minimum is: {y_min_global}')
    print(f'local minimum is: {x_min_global}')
```
### Вывод 
Научился находить локальный минимум при помощи </u>градиентного спуска</u>

## Лабораторная работа № 2

### Разорение игрока
Работа представлена в файлах  `gradient_descent.py` и в `ruining_player.ipynb`

Целью работы является изучение принципа алгоритма случайных блужданий и применить его для решения задачи о разорении игрока.

В данной работе были вредставленны начальные условия согласно варианту.
Условие задачи гласило, что есть два игрока. У первого игрока баланс y, у второго игрока баланс x. У них есть монета с вероятностью 
выпадения орла `p`. Если падает орел то выйгрывает 1 игрок и преумножает свой баланс на 1, а второй игрол теряет -1, в противном случае 
все наоборот.
Требуется найти вероятность проигрыша каждого игрока и вычислить среднюю длину игры.

Исходные данные 
```
p = 0.44  # Вероятность выпадения орла 

# Количество денег 
y = 153  # Баланс 1 игрока
x = 76  # Баланс 2 игрока

N = 1000  # количество игр
N_game = 1000  # количество раундов

```
После чего для определения случайнвых событий была написана функция `random_num()`

```
def random_num():
    return round(random.uniform(0, 1), 2)
```
Данныя функция выводит случайное число от 0 до 1 с точностью до 0.01

Далее написана сама функция в которой происходить `N_game` количство игр по `N` раундов для определения победителей 

```
def sparing():
    
    vin_1 = 0  # Количество побед 1 игрока
    vin_2 = 0  # Количество побед 2 игрока
    none_ = 0  # Количество ничьих
    over_game = []  # Длительность игр
    
    for _ in range(N_game):

        balanced = 0
        count = 0

        for _ in range(N):
            
            random_nums = random_num()
            
            if random_nums <= p:
                balanced += 1
            else:
                balanced -= 1
                
            if balanced >= y:
                vin_1 += 1
                break
                
            if balanced <= -x:
                vin_2 += 1
                break

            count += 1       

        over_game.append(count)

        # Если число игр закончилось, то проверяем кто выйграет 
        if count == N:
            if balanced < 0:
                vin_1 += 1
            elif balanced > 0:
                vin_2 += 1
            else:
                none_ += 1
                
    sp_game = int(sum(over_game)/len(over_game))
    
    winner = 1 if vin_1 > vin_2 else 2
    
    print(f"Победит игрок: {winner} \n")
    
    print(f"Общеe число игр: {N_game} \n")
    
    print(f"Количестов побед у 1 игрока: {vin_1}\n"
          f"Количестов побед у 2 игрока: {vin_2}\n")
    print(f"ср длительность игры: {sp_game}")
    print(
            f"\nПроцент побед у 1 игрока  = {vin_1/N_game}"
            f"\nПроцент побед у 2 игрока = {vin_2/N_game}"
            f"\nПроцент ничьих = {none_/N_game}"
            f"\nПроверка = {(vin_1/N_game)+(vin_2/N_game)+(none_/N_game)} ")

```
### Вывод 

Изучил и смоделировал метод случайных блужданий на примере задачи о разорении игрока.

## Лабораторная работа № 3

### Методы численного интегрирования 
Работа представлена в файлах  `numerical_solution_integrals.py` и в `numerical_solution_integrals.ipynb`

Целью работы является изучение рассчета определенного интеграла заданной функции на интервале методами :

* Метод левых прямоугольников
* Метод правых прямоугольников
* Метод Монте-Карло
* Метод Симпсона

В данной работе нам были представлены исходные данные и определенный интеграл `integral`  

```
# Пределы интегрирования
start_int = 1 
end_int = 3

n = 1000  # количество прямоугольников

h = (end_int - start_int) / n  # ширина прямоугольника


def integral(x):
    return ((x**2)*(np.exp(x)))/((x+2)**2) 
```

Для опеределение погрешности решим наш интеграл в функции `ret`
``` 
def ret():
    return quad(integral, start_int, end_int)[0]
```

В функции `graf` представленно построение графика 

Далее рассмотрим решение интеграла для метода левых прямоугольников и метода правых прямоугольников
Методы левых и правых прямоугольников для вычисления определенного интеграла заключаются в аппроксимации площади 
под кривой графика функции на отрезке интегрирования с помощью прямоугольников, высота которых определяется значением
функции на левой или правой границе каждого подотрезка.

Представлены в функциях `left_rectandles` и `right_rectandles`
```
def left_rectandles():
    print("Метод левых прямоугольников", end="\n")
    
    total = sum([integral((start_int + (k*h))) for k in range(0, n)])
    
    result = h * total
    print(f"Результат: {result}\n")
    
    return result
```
``` 
def right_rectandles():
    print("Метод правых прямоугольников", end="\n")
   
    total = sum([integral((start_int+h + (k*h))) for k in range(0, n)])
    
    result = h * total
    print(f"Результат: {result}\n")
    
    return result
```
Рассмотрим метод трапеций 

Метод трапеций схож с методами левых и правых прямоугольников, за исключением что учитывается не только значение функции
в левой или правой граничной точке каждого отрезка, но и значения на обеих граничных точках.
Это позволяет увеличить точность приближения и уменьшить погрешность вычислений.

Представлены в функции `trapezoid`
``` 
def trapezoid():
    print("Метод трапеции", end="\n")

    sum_ = 0.5 * (integral(start_int)+integral(end_int))
    
    total = sum([integral((start_int + k*h)) for k in range(0, n)])
    
    result = h * (total+sum_)
    print(f"Результат: {result}\n")
    return result
```

Рассмотрим метод Монте-Карла 

Метод Монте-Карло для вычисления определенного интеграла заключается в использовании случайной выборки точек внутри
области интегрирования и аппроксимации значения интеграла с помощью среднего значения функции в этих точках,
умноженного на площадь области интегрирования 

Представлены в функции `monte_carlo`

``` 
def monte_carlo():
    print("Метод Монте Карло ", end="\n")
    
    total = 0
    
    for i in range(1, n):
        rangom_num = start_int + random.random() * (end_int-start_int)
    
        intes = integral(rangom_num)   
        
        total += h * intes
        
    print(f"Результат: {total}\n")
    
    return total
```
Рассмотрим метод Симпсона

Метод Симпсона - численный метод для вычисления определенного интеграла, основанный на аппроксимации подынтегральной
функции кусочно-кубическими параболами на каждом интервале разбиения отрезка интегрирования.

Представлены в функции `simpsons`
``` 
def simpsons():
    print("Метод Симпсона ", end="\n")

    temp = 0.0
    # для нечетных
    x = start_int + h
    for i in range(1, int(n / 2 + 1)):
        temp += 4 * integral(x)
        x += 2 * h

    # для четных
    x = start_int + 2 * h
    for i in range(1, int(n / 2)):
        temp += 2 * integral(x)
        x += 2 * h

    total = (h / 3) * (integral(start_int) + integral(end_int) + temp)
    
    print(f"Результат: {total}\n")
    
    return total
```
В функция `pog` демонстрирует значение полученные при решении интеграла разными методами и расчет погрешности для этих методов 

### Вывод 
Научился решать определеный интеграл различным методами численного интегрирования, самым точным из которых, 
исходя из погрешности, для данного примера оказался метод Симпсона.

## Лабораторная работа № 4

### Метод численного решения уравнений 
Работа представлена в файлах  `method_solving_equations.py` и в `method_solving_equations.ipynb`

Целью работы является изучение и применения метода бисекций и метода хорд для решения уравнения  

В данной работе нам былb предоставлены начальные значенения и начальная функция `f(x)`

``` 
a = 1
b = 2
xx = 10 ** (-7)  # критерий останова

def f(x):
    return np.cos(x) * np.log10(x**4) - (x * np.cos(x)) 
```

Построение графика  `f(x)` предсталено в функции `graf`

Метод бисекции — это численный метод решения уравнений, основанный на том, что если функция непрерывна на отрезке
и принимает значения разных знаков на концах этого отрезка, то на этом отрезке существует корень уравнения. 
Метод заключается в последовательном делении отрезка пополам и определении в какой половине отрезка находится корень 
уравнения. По мере уменьшения размера отрезка точность решения увеличивается.

Метод передставден в функции `bisection_method`

``` 
def bisection_method(start=a, end=b, tol=xx):

    if f(start) * f(end) >= 0:
        print("ошибка")
        return None
    
    while (end - start) / 2 > tol:
        c = (start + end) / 2
        if f(c) == 0:
            return c
        elif f(c) * f(start) < 0:
            end = c
        else:
            start = c
            
    return (start + end) / 2 

```

Метод хорд - численный метод для приближенного нахождения корня уравнения путем построения хорды (отрезка, 
соединяющего концы отрезка с известными значениями функции) и последующего сужения отрезка, содержащего корень, 
до заданной точности.

Метод передставден в функции `chord_method`

``` 
def chord_method(start=a, end=b, tol=xx):
    while (end-start) / 2 > tol:
        c = end - f(end) * (end-start) / (f(end)-f(start))
        if f(c) == 0:
            return c
        elif f(c) * f(start) < 0:
            end = c
        else:
            start = c
    return (start+end) / 2
```

### Вывод
Изучил и смоделирова методы численного решения уравнений методом Бисекций и методом Хорд, но  не все из эти методов 
работают для любых математических выражений.
